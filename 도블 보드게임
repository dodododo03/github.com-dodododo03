<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Dobble Game</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --card-bg: #ecf0f1;
            --accent-color: #e74c3c;
            --text-color: #2c3e50;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none; /* ë“œë˜ê·¸ ë°©ì§€ */
        }

        /* ìƒë‹¨ UI */
        #game-info {
            color: white;
            font-size: 1.5rem;
            margin-bottom: 20px;
            text-align: center;
        }

        #score-board span {
            font-weight: bold;
            color: #f1c40f;
        }

        /* ê²Œì„ ì˜ì—­ */
        #game-area {
            display: flex;
            gap: 40px;
            justify-content: center;
            align-items: center;
        }

        /* ì¹´ë“œ ìŠ¤íƒ€ì¼ (ì›í˜•) */
        .card {
            width: 300px;
            height: 300px;
            background-color: var(--card-bg);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
        }

        .card:hover {
            transform: scale(1.02);
        }

        /* ì‹¬ë³¼ ìŠ¤íƒ€ì¼ */
        .symbol {
            position: absolute;
            font-size: 3rem; /* ê¸°ë³¸ í¬ê¸° */
            transform-origin: center;
            cursor: pointer;
            transition: transform 0.1s;
            /* í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ë°©ì§€ ë° ì´ëª¨ì§€ ì •ë ¬ */
            white-space: nowrap;
            line-height: 1;
            user-select: none;
        }

        .symbol:active {
            transform: scale(0.8) !important; /* í´ë¦­ ì‹œ ëˆŒë¦¬ëŠ” íš¨ê³¼ */
        }

        /* ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ */
        @keyframes pop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .animate-pop {
            animation: pop 0.3s ease-out;
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        .shake {
            animation: shake 0.3s ease-in-out;
        }

        /* ë°˜ì‘í˜• ì²˜ë¦¬ */
        @media (max-width: 700px) {
            #game-area {
                flex-direction: column;
                gap: 20px;
            }
            .card {
                width: 240px;
                height: 240px;
            }
            .symbol {
                font-size: 2.2rem;
            }
        }
    </style>
</head>
<body>

    <div id="game-info">
        <div id="score-board">Score: <span id="score">0</span></div>
        <div style="font-size: 1rem; margin-top:5px; color:#bdc3c7;">ê³µí†µëœ ê·¸ë¦¼ì„ ì°¾ì•„ í´ë¦­í•˜ì„¸ìš”!</div>
    </div>

    <div id="game-area">
        <div id="card-left" class="card"></div>
        <div id="card-right" class="card"></div>
    </div>

    <script>
        /**
         * 1. DobbleMath: í•µì‹¬ ì¹´ë“œ ìƒì„± ì•Œê³ ë¦¬ì¦˜ (ìœ í•œ ì‚¬ì˜ í‰ë©´)
         */
        class DobbleMath {
            constructor(order) {
                this.n = order; // ì°¨ìˆ˜ (ì‹¬ë³¼ ê°œìˆ˜ = n + 1)
                this.totalSymbols = this.n * this.n + this.n + 1;
                this.deck = [];
            }

            generateDeck() {
                const n = this.n;
                let deck = [];

                // 1. ì²« ë²ˆì§¸ ì‹œë¦¬ì¦ˆ: (0, 1, ..., n) í˜•íƒœì˜ ì²« ì¹´ë“œ ìƒì„±ì— ê´€ì—¬í•˜ëŠ” ê·¸ë£¹
                for (let i = 0; i <= n; i++) {
                    let card = [0]; // 0ë²ˆ ì‹¬ë³¼(ë¬´í•œëŒ€ì )ì„ ê³µìœ 
                    for (let j = 0; j < n; j++) {
                        card.push((j + 1) + (i * n));
                    }
                    deck.push(card);
                }

                // 2. ë‘ ë²ˆì§¸ ì‹œë¦¬ì¦ˆ: ë‚˜ë¨¸ì§€ n x n ê°œì˜ ì¹´ë“œ ìƒì„±
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        let card = [i + 1]; // ê¸°ì¤€ì 
                        for (let k = 0; k < n; k++) {
                            // í•µì‹¬ ìˆ˜í•™ ê³µì‹: (n + 1 + n*k + (i*k + j) % n)
                            let val = (n + 1) + (n * k) + ((i * k + j) % n);
                            card.push(val);
                        }
                        deck.push(card);
                    }
                }
                
                this.deck = deck;
                return deck;
            }
        }

        /**
         * 2. GameState: ê²Œì„ì˜ ìƒíƒœ(ì ìˆ˜, í˜„ì¬ ì¹´ë“œ ë“±) ê´€ë¦¬
         */
        class GameState {
            constructor(order) {
                this.math = new DobbleMath(order);
                this.fullDeck = [];
                this.currentPair = []; // [cardA, cardB]
                this.score = 0;
                
                // ì‚¬ìš©í•  ì´ëª¨ì§€ í’€ (IDì™€ ë§¤í•‘ë¨)
                this.symbols = [
                    'ğŸ','ğŸŒ','ğŸ‡','ğŸ‰','ğŸ’','ğŸ“','ğŸ','ğŸ¥','ğŸ¥‘','ğŸ†',
                    'ğŸŒ½','ğŸ¥•','ğŸ¥”','ğŸ¥¦','ğŸ„','ğŸ¥œ','ğŸ','ğŸ¥','ğŸ¥–','ğŸ¥¨',
                    'ğŸ§€','ğŸ–','ğŸ—','ğŸ”','ğŸŸ','ğŸ•','ğŸŒ­','ğŸ¥ª','ğŸŒ®','ğŸŒ¯',
                    'ğŸ³','ğŸ¥˜','ğŸ²','ğŸ¥£','ğŸ¥—','ğŸ¿','ğŸ§‚','ğŸ¥«','ğŸ±','ğŸ™',
                    'ğŸ¤','ğŸ¥','ğŸ¥®','ğŸ¡','ğŸ¥Ÿ','ğŸ¥ ','ğŸ¥¡','ğŸ¦','ğŸ§','ğŸ¨',
                    'ğŸ©','ğŸª','ğŸ‚','ğŸ°','ğŸ§','ğŸ¥§','ğŸ«','ğŸ¬','ğŸ­','ğŸ®'
                ];
            }

            initGame() {
                // ë± ìƒì„± ë° ì…”í”Œ (ëœë¤ì„±ì„ ì—¬ê¸°ì„œ ë¶€ì—¬)
                this.fullDeck = this.math.generateDeck();
                this.shuffle(this.fullDeck);
                this.score = 0;
                this.nextRound();
            }

            // Fisher-Yates Shuffle
            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            nextRound() {
                if (this.fullDeck.length < 2) {
                    // ë± ì†Œì§„ ì‹œ ë‹¤ì‹œ ìƒì„± (ë¬´í•œ ëª¨ë“œ)
                    this.fullDeck = this.math.generateDeck();
                    this.shuffle(this.fullDeck);
                }
                // ì•ì—ì„œ ë‘ ì¥ì„ êº¼ë‚´ì„œ ëŒ€ê²°
                const cardA = this.fullDeck.pop();
                const cardB = this.fullDeck[this.fullDeck.length - 1]; // í•˜ë‚˜ëŠ” ë‚¨ê²¨ë‘ê³  ì—°ê²°ë˜ëŠ” ëŠë‚Œì„ ìœ„í•´ (í˜¹ì€ ê·¸ëƒ¥ 2ê°œ popí•´ë„ ë¨)
                
                // ì‹¤ì œ ê²Œì„ì„±ì„ ìœ„í•´ cardBëŠ” ë±ì—ì„œ ì™„ì „íˆ ì œê±°í•˜ì§€ ì•Šê³  ë‹¤ìŒ ë¼ìš´ë“œì˜ cardAê°€ ë˜ê²Œ í•  ìˆ˜ë„ ìˆìŒ.
                // ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœí•¨ì„ ìœ„í•´ ë§¤ë²ˆ 2ì¥ì„ ìƒˆë¡œ ë½‘ëŠ” ë¡œì§ ëŒ€ì‹ ,
                // ì´ì „ ìŠ¹ì ì¹´ë“œë¥¼ ìœ ì§€í•˜ëŠ” ë°©ì‹ì„ ì“°ê±°ë‚˜, ê·¸ëƒ¥ ëœë¤ 2ì¥ ë½‘ê¸°ë¥¼ êµ¬í˜„.
                // (ìš”êµ¬ì‚¬í•­: ë§íˆë©´ ë‹¤ìŒ ì¹´ë“œë¡œ ì§„í–‰) -> ë±ì—ì„œ 2ì¥ ë½‘ì•„ì„œ ì„¸íŒ….
                
                this.currentPair = [cardA, cardB];
                return this.currentPair;
            }

            checkAnswer(symbolId) {
                const [cardA, cardB] = this.currentPair;
                // ë‘ ì¹´ë“œ ëª¨ë‘ì— í•´ë‹¹ IDê°€ ìˆëŠ”ì§€ í™•ì¸
                if (cardA.includes(symbolId) && cardB.includes(symbolId)) {
                    this.score++;
                    return true;
                }
                return false;
            }

            getSymbolChar(id) {
                return this.symbols[id % this.symbols.length];
            }
        }

        /**
         * 3. Renderer: í™”ë©´ ê·¸ë¦¬ê¸° ë° ìœ„ì¹˜ ê³„ì‚°
         */
        class Renderer {
            constructor(state) {
                this.state = state;
                this.leftCardEl = document.getElementById('card-left');
                this.rightCardEl = document.getElementById('card-right');
                this.scoreEl = document.getElementById('score');
            }

            render() {
                const [deckA, deckB] = this.state.currentPair;
                this.renderCard(this.leftCardEl, deckA);
                this.renderCard(this.rightCardEl, deckB);
                this.scoreEl.innerText = this.state.score;
            }

            // ì¹´ë“œë¥¼ ì›í˜•ìœ¼ë¡œ ë°°ì¹˜í•˜ì—¬ ë Œë”ë§
            renderCard(container, symbolIds) {
                container.innerHTML = ''; // ì´ˆê¸°í™”
                
                // ì‹œê°ì  ì…”í”Œ: ê°™ì€ ì¹´ë“œë¼ë„ ë§¤ë²ˆ ë°°ì¹˜ê°€ ë‹¬ë¼ ë³´ì´ê²Œ í•˜ê¸° ìœ„í•´ ë°°ì—´ ìˆœì„œë¥¼ ì„ìŒ
                const shuffledIds = [...symbolIds]; 
                this.shuffleArray(shuffledIds);

                const count = shuffledIds.length;
                const radius = 100; // ì¤‘ì‹¬ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ (px)
                const centerOffset = 150; // ì¹´ë“œ ì¤‘ì‹¬ì  (width/2)

                shuffledIds.forEach((id, index) => {
                    const symbolEl = document.createElement('div');
                    symbolEl.classList.add('symbol');
                    symbolEl.innerText = this.state.getSymbolChar(id);
                    symbolEl.dataset.id = id; // ë°ì´í„° ì†ì„±ìœ¼ë¡œ ID ì €ì¥

                    // ì›í˜• ë°°ì¹˜ ì¢Œí‘œ ê³„ì‚°
                    // 360ë„ë¥¼ Në“±ë¶„í•˜ë˜, ì•½ê°„ì˜ ëœë¤ì„±ì„ ì¶”ê°€í•´ ìì—°ìŠ¤ëŸ½ê²Œ ë§Œë“¦
                    const angleStep = (2 * Math.PI) / count;
                    const angle = index * angleStep; // ì •ì„ ë°°ì¹˜
                    
                    // ìœ„ì¹˜ ê³„ì‚° (ì‚¼ê°í•¨ìˆ˜)
                    const x = centerOffset + radius * Math.cos(angle);
                    const y = centerOffset + radius * Math.sin(angle);

                    // ëœë¤ íšŒì „ ë° í¬ê¸° ì¡°ì ˆ (ì¥ì‹ ìš”ì†Œ)
                    const randomRot = Math.floor(Math.random() * 360);
                    const randomScale = 0.8 + Math.random() * 0.5; // 0.8 ~ 1.3ë°°

                    symbolEl.style.left = `${x}px`;
                    symbolEl.style.top = `${y}px`;
                    symbolEl.style.transform = `translate(-50%, -50%) rotate(${randomRot}deg) scale(${randomScale})`;

                    container.appendChild(symbolEl);
                });

                // ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜
                container.classList.remove('animate-pop');
                void container.offsetWidth; // ë¦¬í”Œë¡œìš° ê°•ì œ (ì• ë‹ˆë©”ì´ì…˜ ë¦¬ì…‹)
                container.classList.add('animate-pop');
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            shakeBoard() {
                const area = document.getElementById('game-area');
                area.classList.remove('shake');
                void area.offsetWidth;
                area.classList.add('shake');
            }
        }

        /**
         * 4. Main & Event Handling
         */
        const ORDER = 5; // ì°¨ìˆ˜ 5 -> í•œ ì¹´ë“œì— 6ê°œ ê·¸ë¦¼
        const gameState = new GameState(ORDER);
        const renderer = new Renderer(gameState);

        // ê²Œì„ ì´ˆê¸°í™”
        gameState.initGame();
        renderer.render();

        // ì´ë²¤íŠ¸ ìœ„ì„ (Event Delegation) - ì„±ëŠ¥ ìµœì í™”
        document.getElementById('game-area').addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('symbol')) {
                const clickedId = parseInt(e.target.dataset.id);
                
                if (gameState.checkAnswer(clickedId)) {
                    // ì •ë‹µ ë¡œì§
                    // 1. ì ìˆ˜ ì¦ê°€ (ë‚´ë¶€ ì²˜ë¦¬ë¨)
                    // 2. ìƒˆë¡œìš´ ì¹´ë“œ ì„¸íŒ…
                    gameState.nextRound();
                    // 3. ë Œë”ë§
                    renderer.render();
                } else {
                    // ì˜¤ë‹µ ë¡œì§
                    renderer.shakeBoard();
                }
            }
        });

    </script>
</body>
</html>
